
- [Suggestions](#suggestions)
  - [generateSuggestion](#generatesuggestion)
  - [generateExpressionSuggestion](#generateexpressionsuggestion)
    - [calling generateExpressionSuggestion](#calling-generateexpressionsuggestion)
    - [consuming input](#consuming-input)
    - [swapping arguments](#swapping-arguments)
      - [note on indexing for swapping](#note-on-indexing-for-swapping)
      - [example with tree swaps:](#example-with-tree-swaps)
    - [addToAccumulator](#addtoaccumulator)
- [Token Difference](#token-difference)
  - [types to token streams](#types-to-token-streams)
  - [generating the differences](#generating-the-differences)
    - [performance](#performance)

# Suggestions
in short suggestions are generated as follows. 
1. take the token stream with a problem.
2. generate a expression/section as an AST using these tokens and type information.
3. transform this suggestion back into (every possible) token stream that could generate this expression.
4. calculate the difference in tokens given and the ones generated as suggestion and present it to the user.

## generateSuggestion
`generateSuggestion :: Int -> Map.Map String Type -> [TokenInfo] -> MaybeError ([ExtendedTokens], String, String, Type, Int)`
is responsible for generating suggestions for function definitions. 
it takes:
- the current state for fresh variables.
- a type enviornment
- a tokenstream

It produces either an error or a collection of
- a list of expected tokens.
- a plain string representation of the final expression that could be copied.
- a string representation of the difference using colours.
- the type of the function
- the number of branches where we had to backtrack for performance. 

To do this we first split on the first `=` sign and peel off the function name. all the tokens to the left of the `=` will be the arguments while the tokens on the right will be used to generate a suggestion.

If the function we are trying to make a suggestion for has a type we assign the arguments the corresponding types and put those in the type environment. if there is no type we assign them free variables.

we take this type environment and use it to build a suggestionbuilder. 
we call `generateExpressionSuggestion` with the goal either a free variable or (If the function we are trying to make a suggestion for has a type) we give the type of the function subtracting all the types of the arguments. 

Here we still support functions like `myFun :: Int -> Int -> Int` where we only have `myFun x = ...` here the goal will simply be `Int -> Int` as only one argument is given in the function definition.

once the expression suggestions are generated we use the first valid suggestion (type matches goal) to build up our suggestion as a `Section` (the type for function definitions or type declarations).

finally we use some functions from `TokenDifference` to build the suggestion Strings. 

## generateExpressionSuggestion
the `generateExpressionSuggestion :: Type -> Maybe Type -> [Candidate] -> SuggestionBuilder [Candidate]` function is responsible for generating expression suggestions. 
here, a `Candidate` is defined as `type Candidate = (WithSimplePos Expr, Type, SuggestionBuilderState)`
Candidate holds suggested expressions and their type, it also holds the state of the program at the point it was generated for backtracking purposes.

candidates are generated by iteratively eating one more argument to to a function. It returns each candidate it has found.
example:
take 
```
trice :: (a -> a) -> a -> a
trice f x =  f (f (f x)) 
```
generating a suggestion for `trice plus 5 6`
would give us:
```hs
[ (trice (plus 5) 6 , Int               , state)
, (trice (plus 5)   , Int -> Int        , state)
, (trice            , (a -> a) -> a -> a, state)
]
```
where state is used to revert taking tokens
when it encountered the second `plus` it was called recursively with the remaining input `plus 5 6`
resulting in: 
```hs
[ (plus 5 6 , Int               , state)
, (plus 5   , Int -> Int        , state)
, (plus     , Int -> Int -> Int , state)
]
```
note how it did not take the most greedy result here since `Int` would not fit in the first argument of trice `(a -> a)`
### calling generateExpressionSuggestion
`generateExpressionSuggestion :: Type -> Maybe Type -> [Candidate] -> SuggestionBuilder [Candidate]` takes three arguments.
If you just want it to build a suggestion you can all it like so `generateExpressionSuggestion goal Nothing []` where goal is the type the suggestion should be. 

NOTE: the goal is mainly used for performance. it can still return candidates that do **not** match the goal! <!-- TODO: see if we need this --> 

the second and third arguments are used when plugging in arguments to a function.
the second argument `currentProcessType :: Maybe Type` holds the type of the function you are currently plugin arguments into. as soon as an argument is plugged in this type should be updated to reflect that. 

The third argument is the accumulator holing all the found candidates thus far.
### consuming input
consuming input starts by calling getExpr which will look at the next token (ignoring parenthesis) and returns it and its type as a candidate.

then one of two things will happen:
1. If the type of the candidate is some constant it will return the candidate as a singleton list.

2. If the type of the candidate is a function we switch the `generateExpressionSuggestion` into the function processing mode. meaning that we call it with the currentProcessType being `Just candidate_type` where candidate_type is the function type we just found.
Then we will call generateExpressionSuggestion normally to get the candidates for the first argument.
Then we try to fit the candidates into the first argument. We take the first argument we find that fits starting with the candidate that consumed the most tokens.
when it fits we use the substitution this generates and apply it to the return type of the function.
(Note: we take the view here that every function only takes one argument and the rest is the return type)
then this return type is the new currentProcessType for calling generateExpressionSuggestion.
we also construct the expression by taking the expression of the candidate with the fitting type and add it to the previously found expression that is currently in the accumulator.
this expression is added to the accumulator before calling generateExpressionSuggestion recursively.

the recursion stops when the currentProcessType is not a function and no more arguments could be plugged in. 

If no arguments fit we do not have to fail as we may partially apply functions. 
in this case we just return the accumulator. However we can do slightly better, if no arguments fit the programmer might have made a mistake here. So, we first check if the programmer accidentally swapped some arguments before returning the accumulator. more on this in the next section.  

### swapping arguments
Take `stringRepeat:: Int -> String -> String`
If a programmer types `stringRepeat "hello " 5` they probably misremembered the type of stringRepeat.
Rather than giving two type errors we want to give the suggestion that they should swap `"hello "` and `5`.
as seen in the previous section we try to do this when no candidates fit.

when no candidates fit the goal we recalculate the candidates with a free variable as to goal to make sure we can suggest any input.

we look at the first candidate and then we use `firstMatchToFront :: Type -> [Type] -> Maybe (Int, [Type])` to see from the list of all arguments if there is a match.
if there is no match anywhere we just try the next candidate.
If there is a match in any of the arguments we get the arguments reordered where the first match is now in the front. We also get the index which we'll use later to undo this swapping. 
we will hold this candidate for a while. Then we generate an expression as normal as if the currentProcessType is this new "reorderedType" type where we can just take off the first argument as we just saw that this fits. 
example for thus far:
for `stringRepeat "hello " 5` we see that we find a `"hello "::String` but that doesn't fit in `stringRepeat:: Int -> String -> String` we do see that if the arguments were `String -> Int -> String` it would fit. because we are going to hold `"hello "::String` to the side for a bit we continue generating as if we have just parsed `stringRepeat :: Int -> String` with the remainign input `5`. this will generate the following candidates:
```hs
[ (stringRepeat 5 , String                  , state)
, (stringRepeat   , Int -> String -> String , state)
]
```
now we do need to put the candidate we've been holding onto back into the type. 
We use the `insertIntoExpressionAtIndex :: Int -> WithSimplePos Expr -> WithSimplePos Expr -> Maybe (WithSimplePos Expr)` for that.
we can give it the index and if the generated expression is big enough for the candidate we've been holding to be inserted it will insert it. otherwise we get nothing.
in our example transfor the candidates from above into:
```hs
[ (stringRepeat 5 "hello ", String          , state)
]
```
this removes too many candidates as the candidates generated before the swapping are still valid. so we just add the current accumulator back on the end.
this finishes our example:
```hs
[ (stringRepeat 5 "hello ", String          , state)
, (stringRepeat   , Int -> String -> String , state)
]
```

this approach works with a function with any number of arguments or required swaps.

#### note on indexing for swapping
`firstMatchToFront` should take the current goal to figure out the index.
for example if we have `fun :: String -> Bool -> Int -> Bool -> Int -> String`
and we've given the input `fun "hi" 4 5 True False` (the two booleans and two integers should be swapped here)
the first `hi` is applied then the `4` processed. we see that it doesn't fit and hold it for later. The new currentProcessType becomes `Bool -> Bool -> Int -> String` we need to process the `5` next, here it is important that we use this new currentProcessType so that we remove the right int. 
from `firstMatchToFront` we'll get index 2 as that is where it needs to be inserted in the currentProcessType. However, we already consumed a String in this case. So we need to keep the number of arguments already processed into account for generating the final index. since here a sting is already consumed as argument we need to add 1 to the index. 

In practice we do this by looking at the most greedy suggestion in our accumulator and counting how many arguments it has taken already.

#### example with tree swaps:
take `fun :: Bool -> Bool -> String -> Int -> Int -> String`
which we call with `fun 4 5 True "hi" False `
first we hold `4` (to be inserted at position 3) and recursively call as is the type is `Bool -> Bool -> String -> Int -> String`
then we hold `5` (to be inserted at position 3)  and recursively call as is the type is `Bool -> Bool -> String -> String`
then `True` just fits so we continue with `Bool -> String -> String`
then we hold `"hi"` (to be inserted at position 2) and recursively call as is the type is `Bool -> String`
finally `False` fits and we end up with the suggestion:
```hs
[ (fun True False , String                                         , state)
, (fun True       , Bool -> String -> String                       , state)
, (fun            , Bool -> Bool -> String -> Int -> Int -> String , state)
]
```
we add `"hi"` back in position 2
```hs
[ (fun True False "hi" , String                                         , state)
, (fun True            , Bool -> String -> String                       , state)
, (fun                 , Bool -> Bool -> String -> Int -> Int -> String , state)
]
```
we add `5` back in in position 3
```hs
[ (fun True False "hi" 5 , String                                         , state)
, (fun                   , Bool -> Bool -> String -> Int -> Int -> String , state)
]
```

finally we add `4` back in in position 3
```hs
[ (fun True False "hi" 4 5 , String                                         , state)
, (fun                     , Bool -> Bool -> String -> Int -> Int -> String , state)
]
```

### addToAccumulator

`addToAccumulator` adds the candidate to the accumulator. (regardless of the goal)
Its purpose is to make sure substitutions are handled.

If the candidate type matches the goal the substitution will also be applied to the candidates type and state.
It will revert the state of the suggestion builder to before this substitution so one can continue taking arguments.

<!-- TODO: add good example --> 

performance: maybe only if the function could end up in the goal instead of always.

# Token Difference
The tokenDifference module is responsible for converting build in types to token streams that could be used to generate them. 
and it is responsible for taking such streams and an actual stream and finding the smallest difference between the two.

## types to token streams
we introduce 
```hs
data ExtendedTokens
  = Require Token
  | Optional Token (Maybe Int)
```
where we either say we require a token or that a token is optional. optional tokens may have an id with them. if one chooses to use an optional token with such an id all others with that id must also be used.

as an example say we have the expression `plus 4 5` as an internal `Expr` we must be able to construct the possible token streams that can be used to generate this expression unfortunately there are multiple:
```hs
plus 4 5
(plus 4) 5
((plus 4) 5)
```
these are parsed identically. to encode this we get the following
```hs
Optional '(' Just 0 
Optional '(' Just 1
Required "plus"
Required 4
Optional ')' Just 1
Required 5
Optional ')' Just 0 
```
This is only a slight simplification as `(((plus) (4)) 5)` would also be valid. but that makes the example unwieldy. 

It turns out these are relatively straightforward to generate from the dataTypes.

## generating the differences
a list of `ExtendedTokens` does not make an suggestion, we want to respect unnecessary parenthesis and want to suggest a token stream that is a s close to the original (faulty) token stream as possible.

to do this we use `generateActions :: [ExtendedTokens] -> [Token] -> [Action Token]`
it takes the `ExtendedTokens` and the original tokens and gives us a list of action tokens.
```hs
data Action a
  = Keep a
  | Add a
  | Remove a
```
an action will tell you if a token should be added to the original token stream, it it should be kept or if one should be removed. 

we do this in a similar manor to how the Levenshtein distance is usually implemented. 
for each token we effectively check if we should keep remove or add it. removing or adding increases the distance. then we take the minimum of all these options. 

### performance
to generate this difference we do not always decide to add or remove, if the required token and the token in the original is the same we just keep it without looking at deletion or addition. 

we also use dynamic programming, meaning we store intermediate results because the recursive algorithm often takes two different routes to the same path. this sped up the algorithm **MASSIVELY**. 

in general we believe this difference calculating is currently way more computationally intensive than generating the suggestion in the first place. 