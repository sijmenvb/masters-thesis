
- [Suggestions](#suggestions)
  - [generateSuggestion](#generatesuggestion)
  - [generateExpressionSuggestion](#generateexpressionsuggestion)
    - [calling generateExpressionSuggestion](#calling-generateexpressionsuggestion)
    - [consuming input](#consuming-input)
    - [swapping arguments](#swapping-arguments)
      - [note on indexing for swapping](#note-on-indexing-for-swapping)
      - [example with tree swaps:](#example-with-tree-swaps)
    - [addToAccumulator](#addtoaccumulator)
    - [lambda expression suggestions](#lambda-expression-suggestions)
      - [In detail:](#in-detail)
        - [get the current type environment](#get-the-current-type-environment)
        - [getting the arguments](#getting-the-arguments)
        - [consuming the -\>](#consuming-the--)
        - [adding arguments to the type environment](#adding-arguments-to-the-type-environment)
        - [generating the expression in the lambda](#generating-the-expression-in-the-lambda)
        - [building the type of the lambda expression](#building-the-type-of-the-lambda-expression)
        - [building the lambda expression](#building-the-lambda-expression)
        - [reverting the type environment](#reverting-the-type-environment)
        - [constructing the candidate](#constructing-the-candidate)
- [Token Difference](#token-difference)
  - [types to token streams](#types-to-token-streams)
  - [generating the differences](#generating-the-differences)
    - [performance](#performance)

# Suggestions
in short suggestions are generated as follows. 
1. take the token stream with a problem.
2. generate a expression/section as an AST using these tokens and type information.
3. transform this suggestion back into (every possible) token stream that could generate this expression.
4. calculate the difference in tokens given and the ones generated as suggestion and present it to the user.

## generateSuggestion
`generateSuggestion :: Int -> Map.Map String Type -> [TokenInfo] -> MaybeError ([ExtendedTokens], String, String, Type, Int)`
is responsible for generating suggestions for function definitions. 
it takes:
- the current state for fresh variables.
- a type environment
- a token stream

It produces either an error or a collection of
- a list of expected tokens.
- a plain string representation of the final expression that could be copied.
- a string representation of the difference using colours.
- the type of the function
- the number of branches where we had to backtrack for performance. 

To do this we first split on the first `=` sign and peel off the function name. all the tokens to the left of the `=` will be the arguments while the tokens on the right will be used to generate a suggestion.

If the function we are trying to make a suggestion for has a type we assign the arguments the corresponding types and put those in the type environment. if there is no type we assign them free variables.

we take this type environment and use it to build a suggestionBuilder. 
we call `generateExpressionSuggestion` with the goal either a free variable or (If the function we are trying to make a suggestion for has a type) we give the type of the function subtracting all the types of the arguments. 

Here we still support functions like `myFun :: Int -> Int -> Int` where we only have `myFun x = ...` here the goal will simply be `Int -> Int` as only one argument is given in the function definition.

once the expression suggestions are generated we use the first valid suggestion (type matches goal) to build up our suggestion as a `Section` (the type for function definitions or type declarations).

finally we use some functions from `TokenDifference` to build the suggestion Strings. 

## generateExpressionSuggestion
the `generateExpressionSuggestion :: Type -> Maybe Type -> [Candidate] -> SuggestionBuilder [Candidate]` function is responsible for generating expression suggestions. 
here, a `Candidate` is defined as `type Candidate = (WithSimplePos Expr, Type, SuggestionBuilderState)`
Candidate holds suggested expressions and their type, it also holds the state of the program at the point it was generated for backtracking purposes.

candidates are generated by iteratively eating one more argument to to a function. It returns each candidate it has found.
example:
take 
```
trice :: (a -> a) -> a -> a
trice f x =  f (f (f x)) 
```
generating a suggestion for `trice plus 5 6`
would give us:
```hs
[ (trice (plus 5) 6 , Int               , state)
, (trice (plus 5)   , Int -> Int        , state)
, (trice            , (a -> a) -> a -> a, state)
]
```
where state is used to revert taking tokens
when it encountered the second `plus` it was called recursively with the remaining input `plus 5 6`
resulting in: 
```hs
[ (plus 5 6 , Int               , state)
, (plus 5   , Int -> Int        , state)
, (plus     , Int -> Int -> Int , state)
]
```
note how it did not take the most greedy result here since `Int` would not fit in the first argument of trice `(a -> a)`
### calling generateExpressionSuggestion
`generateExpressionSuggestion :: Type -> Maybe Type -> [Candidate] -> SuggestionBuilder [Candidate]` takes three arguments.
If you just want it to build a suggestion you can all it like so `generateExpressionSuggestion goal Nothing []` where goal is the type the suggestion should be. 

NOTE: the goal is mainly used for performance. it can still return candidates that do **not** match the goal! <!-- TODO: see if we need this --> 

the second and third arguments are used when plugging in arguments to a function.
the second argument `currentProcessType :: Maybe Type` holds the type of the function you are currently plugin arguments into. as soon as an argument is plugged in this type should be updated to reflect that. 

The third argument is the accumulator holing all the found candidates thus far.
### consuming input
consuming input starts by calling getExpr which will look at the next token (ignoring parenthesis) and returns it and its type as a candidate.

then one of two things will happen:
1. If the type of the candidate is some constant it will return the candidate as a singleton list.

2. If the type of the candidate is a function we switch the `generateExpressionSuggestion` into the function processing mode. meaning that we call it with the currentProcessType being `Just candidate_type` where candidate_type is the function type we just found.
Then we will call generateExpressionSuggestion normally to get the candidates for the first argument.
Then we try to fit the candidates into the first argument. We take the first argument we find that fits starting with the candidate that consumed the most tokens.
when it fits we use the substitution this generates and apply it to the return type of the function.
(Note: we take the view here that every function only takes one argument and the rest is the return type)
then this return type is the new currentProcessType for calling generateExpressionSuggestion.
we also construct the expression by taking the expression of the candidate with the fitting type and add it to the previously found expression that is currently in the accumulator.
this expression is added to the accumulator before calling generateExpressionSuggestion recursively.

the recursion stops when the currentProcessType is not a function and no more arguments could be plugged in. 

If no arguments fit we do not have to fail as we may partially apply functions. 
in this case we just return the accumulator. However we can do slightly better, if no arguments fit the programmer might have made a mistake here. So, we first check if the programmer accidentally swapped some arguments before returning the accumulator. more on this in the next section.  

### swapping arguments
Take `stringRepeat:: Int -> String -> String`
If a programmer types `stringRepeat "hello " 5` they probably misremembered the type of stringRepeat.
Rather than giving two type errors we want to give the suggestion that they should swap `"hello "` and `5`.
as seen in the previous section we try to do this when no candidates fit.

when no candidates fit the goal we recalculate the candidates with a free variable as to goal to make sure we can suggest any input.

we look at the first candidate and then we use `firstMatchToFront :: Type -> [Type] -> Maybe (Int, [Type])` to see from the list of all arguments if there is a match.
if there is no match anywhere we just try the next candidate.
If there is a match in any of the arguments we get the arguments reordered where the first match is now in the front. We also get the index which we'll use later to undo this swapping. 
we will hold this candidate for a while. Then we generate an expression as normal as if the currentProcessType is this new "reorderedType" type where we can just take off the first argument as we just saw that this fits. 
example for thus far:
for `stringRepeat "hello " 5` we see that we find a `"hello "::String` but that doesn't fit in `stringRepeat:: Int -> String -> String` we do see that if the arguments were `String -> Int -> String` it would fit. because we are going to hold `"hello "::String` to the side for a bit we continue generating as if we have just parsed `stringRepeat :: Int -> String` with the remaining input `5`. this will generate the following candidates:
```hs
[ (stringRepeat 5 , String                  , state)
, (stringRepeat   , Int -> String -> String , state)
]
```
now we do need to put the candidate we've been holding onto back into the type. 
We use the `insertIntoExpressionAtIndex :: Int -> WithSimplePos Expr -> WithSimplePos Expr -> Maybe (WithSimplePos Expr)` for that.
we can give it the index and if the generated expression is big enough for the candidate we've been holding to be inserted it will insert it. otherwise we get nothing.
in our example transform the candidates from above into:
```hs
[ (stringRepeat 5 "hello ", String          , state)
]
```
this removes too many candidates as the candidates generated before the swapping are still valid. so we just add the current accumulator back on the end.
this finishes our example:
```hs
[ (stringRepeat 5 "hello ", String          , state)
, (stringRepeat   , Int -> String -> String , state)
]
```

this approach works with a function with any number of arguments or required swaps.

#### note on indexing for swapping
`firstMatchToFront` should take the current goal to figure out the index.
for example if we have `fun :: String -> Bool -> Int -> Bool -> Int -> String`
and we've given the input `fun "hi" 4 5 True False` (the two booleans and two integers should be swapped here)
the first `hi` is applied then the `4` processed. we see that it doesn't fit and hold it for later. The new currentProcessType becomes `Bool -> Bool -> Int -> String` we need to process the `5` next, here it is important that we use this new currentProcessType so that we remove the right int. 
from `firstMatchToFront` we'll get index 2 as that is where it needs to be inserted in the currentProcessType. However, we already consumed a String in this case. So we need to keep the number of arguments already processed into account for generating the final index. since here a sting is already consumed as argument we need to add 1 to the index. 

In practice we do this by looking at the most greedy suggestion in our accumulator and counting how many arguments it has taken already.

#### example with tree swaps:
take `fun :: Bool -> Bool -> String -> Int -> Int -> String`
which we call with `fun 4 5 True "hi" False `
first we hold `4` (to be inserted at position 3) and recursively call as is the type is `Bool -> Bool -> String -> Int -> String`
then we hold `5` (to be inserted at position 3)  and recursively call as is the type is `Bool -> Bool -> String -> String`
then `True` just fits so we continue with `Bool -> String -> String`
then we hold `"hi"` (to be inserted at position 2) and recursively call as is the type is `Bool -> String`
finally `False` fits and we end up with the suggestion:
```hs
[ (fun True False , String                                         , state)
, (fun True       , Bool -> String -> String                       , state)
, (fun            , Bool -> Bool -> String -> Int -> Int -> String , state)
]
```
we add `"hi"` back in position 2
```hs
[ (fun True False "hi" , String                                         , state)
, (fun True            , Bool -> String -> String                       , state)
, (fun                 , Bool -> Bool -> String -> Int -> Int -> String , state)
]
```
we add `5` back in in position 3
```hs
[ (fun True False "hi" 5 , String                                         , state)
, (fun                   , Bool -> Bool -> String -> Int -> Int -> String , state)
]
```

finally we add `4` back in in position 3
```hs
[ (fun True False "hi" 4 5 , String                                         , state)
, (fun                     , Bool -> Bool -> String -> Int -> Int -> String , state)
]
```

### addToAccumulator

`addToAccumulator` adds the candidate to the accumulator. (regardless of the goal)
Its purpose is to make sure substitutions are handled.

If the candidate type matches the goal the substitution will also be applied to the candidates type and state.
It will revert the state of the suggestion builder to before this substitution so one can continue taking arguments.

<!-- TODO: add good example --> 

performance: maybe only if the function could end up in the goal instead of always.

### lambda expression suggestions
Lambda expressions are generated similarly to [`generateSuggestion`](#generatesuggestion). When we call the internal `getExpr` and find a lambda `\` we try to generate a lambda expression.

In short it works as follows:
1. get the current type environment to revert to later
2. get the tokens that represent the arguments
3. add the tokens to the type environment
4. generate an expression (and type) with this new environment
5. read the types from the arguments from the now updated type environment
6. use the generated expression and type with the arguments and their types to build up a return type and lambda expression that form a candidate.
7. revert the type environment for arguments

#### In detail:
##### get the current type environment
we first get the current type environment. A change in the type environment within a lambda has no effect outside said lambda. So we need to store the current type environment to revert to it later.
##### getting the arguments
We first look at the goal. This is done since we can make better informed decisions when the type of the lambda is known. for example if we know the type should be `Int -> Int -> Int` we know the lambda can take at most two arguments.
Note: if the type is known to be `Int -> Int -> a` it can still have an arbitrary number of arguments since `a` can be a function itself. also, if the type is `Int -> Int -> Int` we can also take fewer than two arguments. for example look at `(\x -> plus x)` which is a lambda of type `Int -> Int -> Int` that only takes one argument in the lambda definition.

If we know the type and it does not end in a variable we can stop taking arguments whenever we've reached the number of arguments. So if we know the desired type is e.g. `Int -> Int -> Int` and the given expression is 
```hs 
(\x y plus x y)
```

then we know that after the `y` we have consumed the two arguments and can go on to consume a `->`. 
##### consuming the ->
in the example above the `->` is missing. so we only consume the `->` if it exists if it does not we just assume the programmer missed it. 

we also stop taking arguments as soon as we encounter something that is not a label this means we stop taking arguments as soon as we see a `->` but also if we see a `=` or some other symbol. Sine we still only try to consume the `->` if there is some other symbol instead we still assume the `->`. and since our building of suggestions ignores unknown tokens it will suggest to remove "other symbol" instead. 
##### adding arguments to the type environment
the expression after the `->` within a lambda can use the arguments of the lambda so they need to be added to teh type environment. 
the arguments can be assigned to free variables. However, we can (sometimes) do better. If we know the goal we already know what the types of the arguments should be. Giving this information helps if there are other mistakes in the lambda like arguments that should be swapped.

to do this we use `addArgumentsToTypeEnvironment :: [Type] -> [TokenInfo] -> SuggestionBuilder [Type]` it takes the type-arguments for the goal and the arguments as tokens and adds them to the type environment if we run out of type arguments we use free variables. It also returns the Types that were not used.
##### generating the expression in the lambda
we use the normal way of calling `generateExpressionSuggestion` for the goal we can combine the unused arguments and the return type of the goal

note: if there "is no goal" the goal will be a free variable. which is also the `goalReturnType`.

This will generate a list of candidates for the body of the lambda.
##### building the type of the lambda expression
we can build the type of the complete lambda if we know the type of the arguments and the type of the expression. 

we can het the types by looking the arguments up using the (now updated) type environment. 

then we can use the `buildTypeFromArguments` to construct the final type

We do this for each candidate expression generated and we'll continue with the first one that fits the goal. (starting with the most greedy version)

##### building the lambda expression
we can reuse the `buildLambdaExpression` to build the lambda from the arguments and generated expression. we also need to add the start position of the lambda. 

note that lambdas like `(\x y -> 4)` are interpreted as `(\x -> (\y -> 4))` internally


##### reverting the type environment
since we now have the lambda expression and it's type we can make sure we revert the type environment for the arguments.

we revert it only for the arguments defined by this lambda as they should not exist outside the lambda (unless they already did and the lambda shadowed them). we cannot revert the entire type environment as applications within the lambda can specialise types.

##### constructing the candidate
to finish up we take the current state (now with the old type environment) the lamda and its type to construct the candidate required.

# Token Difference
The tokenDifference module is responsible for converting build in types to token streams that could be used to generate them. 
and it is responsible for taking such streams and an actual stream and finding the smallest difference between the two.

## types to token streams
we introduce 
```hs
data ExtendedTokens
  = Require Token
  | Optional Token (Maybe Int)
```
where we either say we require a token or that a token is optional. optional tokens may have an id with them. if one chooses to use an optional token with such an id all others with that id must also be used.

as an example say we have the expression `plus 4 5` as an internal `Expr` we must be able to construct the possible token streams that can be used to generate this expression unfortunately there are multiple:
```hs
plus 4 5
(plus 4) 5
((plus 4) 5)
```
these are parsed identically. to encode this we get the following
```hs
Optional '(' Just 0 
Optional '(' Just 1
Required "plus"
Required 4
Optional ')' Just 1
Required 5
Optional ')' Just 0 
```
This is only a slight simplification as `(((plus) (4)) 5)` would also be valid. but that makes the example unwieldy. 

It turns out these are relatively straightforward to generate from the dataTypes.

## generating the differences
a list of `ExtendedTokens` does not make an suggestion, we want to respect unnecessary parenthesis and want to suggest a token stream that is a s close to the original (faulty) token stream as possible.

to do this we use `generateActions :: [ExtendedTokens] -> [Token] -> [Action Token]`
it takes the `ExtendedTokens` and the original tokens and gives us a list of action tokens.
```hs
data Action a
  = Keep a
  | Add a
  | Remove a
```
an action will tell you if a token should be added to the original token stream, it it should be kept or if one should be removed. 

we do this in a similar manor to how the Levenshtein distance is usually implemented. 
for each token we effectively check if we should keep remove or add it. removing or adding increases the distance. then we take the minimum of all these options. 

### performance
to generate this difference we do not always decide to add or remove, if the required token and the token in the original is the same we just keep it without looking at deletion or addition. 

we also use dynamic programming, meaning we store intermediate results because the recursive algorithm often takes two different routes to the same path. this sped up the algorithm **MASSIVELY**. 

in general we believe this difference calculating is currently way more computationally intensive than generating the suggestion in the first place. 